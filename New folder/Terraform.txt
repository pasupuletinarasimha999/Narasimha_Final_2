provider with aws
=====================
provider "aws" {
  version = "~> 5.0"
  region  = "us-east-1"
}

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

required_providers Block: Use this block in the root module to specify provider dependencies and their versions.
provider Block: Use this block to configure the settings for a specific provider.
===================================
Two required_providers
--------------------------
terraform {
    required_providers {
      aws = {
        source  = "hashicorp/aws"
        version = "~> 4.14.0"
        configuration_aliases = [aws.acc1, aws.acc2]
      }
    }
  }
  
  provider "aws" {
    alias  = "acc1"
    region = "eu-central-1"
    assume_role {
      role_arn = "arn:aws:iam::ACC1:role/MyRoleAcc1"
    }
  }
  
  provider "aws" {
    alias  = "acc2"
    region = "eu-central-2"
    assume_role {
      role_arn = "arn:aws:iam::ACC2:role/MyRoleAcc2"
    }
  }
==============================================================
Cross-Referencing Resources
===========================
resource "aws_instance" "web" {
    ami           = data.aws_ami.web.id
    instance_type = "t1.micro"
  }
data "aws_ami" "web" {
    most_recent = true
    owners      = ["self"]
    tags        = { Name = "app-server", Tested = "true" }
  }
================================================================
Local_Values
=============
locals {
    common_tags = {
      Service = local.service_name
      Owner   = local.owner
    }
  }
locals {
    service_name = "forum"
    owner        = "Community Team"
  }
resource "aws_instance" "example" {
    # ...
    tags = local.common_tags
  }
====================================================
conditional expressions
=========================
variable "a" {
    description = "Some value"
    default     = var.a != "" ? var.a : "default-a"
  }
resource "aws_db_instance" "example" {
    name          = var.db_name
    engine        = var.db_engine
    instance_class = var.db_instance_class
    create_if     = var.db_user != null
  }
=================================================
Data sources
=============
data "aws_ami" "ubuntu" {
    most_recent = true
    filter {
      name   = "name"
      values = ["ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-20230325"]
    }
    filter {
      name   = "virtualization-type"
      values = ["hvm"]
    }
    owners = ["099720109477"] # Canonical
  }
  
  data "aws_availability_zones" "available" {
    state = "available"
  }
  
  output "virtual_machine_id" {
    value = data.aws_availability_zones.available.names[0]
  }
  
  output "virtual_machine_id1" {
    value = data.aws_availability_zones.available.names[1]
  }
  
  output "ips_with_list_interpolation" {
    value = [for name in data.aws_availability_zones.available.names : name]
  }
  
  resource "aws_instance" "first-ec2" {
    ami           = data.aws_ami.ubuntu.id
    instance_type = "t2.micro"
    tags = {
      Name = "RajeshKumar"
    }
  }
=======================================================
Dynamic_Block: In Terraform, a dynamic block is used when you need to generate multiple nested blocks within a resource or module dynamically based on a variable or a list.
===========
resource "aws_elastic_beanstalk_environment" "tfenvtest" {
    name = "tf-test-name"
    application = "${aws_elastic_beanstalk_application.tftest.name}"
    solution_stack_name = "64bit Amazon Linux 2018.03 v2.11.4 running Go 1.12.6"
  
    dynamic "setting" {
      for_each = var.settings
      content {
        namespace = setting.value["namespace"]
        name      = setting.value["name"]
        value     = setting.value["value"]
      }
    }
  }

Var file

settings = [
  {
    namespace = "aws:elasticbeanstalk:environment"
    name      = "EnvironmentType"
    value     = "SingleInstance"
  },
  {
    namespace = "aws:elasticbeanstalk:application:environment"
    name      = "MY_ENV_VAR"
    value     = "my-value"
  }
]
=======================================================
Meta-Arguments (create before destroy, prevent destroy, ignore changes, replace triggered by)
==========================
resource "aws_instance" "example" {
    ami           = "ami-0c55b159cbfafe1f0"
    instance_type = "t2.micro"
  
    # Other configuration settings...
  
    lifecycle {
      create_before_destroy = true
    }
  }
resource "azurerm_sql_database" "example" {
    # ... other configuration ...
  
    lifecycle {
      prevent_destroy = true
    }
  }  
  resource "azurerm_virtual_machine" "example" {
    # ...
    lifecycle {
      ignore_changes = [
        "network_interface_ids",
        "storage_os_disk",
        "computer_name",
      ]
    }
  }
  resource "example_database" "test" {
    lifecycle {
      replace_triggered_by = [terraform_data.replacement]
    }
  }
=====================================================================  
For-Each
=========
# my_buckets.tf
module "bucket" {
  for_each = toset(["assets", "media"])
  source   = "./publish_bucket"
  name     = "${each.key}_bucket"
}
             (or)
resource "aws_iam_user" "the-accounts" {
    for_each = toset(["Todd", "James", "Alice", "Dottie"])
  
    name = each.key
  }
            (or)
resource "azurerm_resource_group" "rg" {
    for_each = tomap({
      a_group       = "eastus"
      another_group = "westus2"
    })
  
    name     = each.key
     location = each.value
  }
=====================================================
Local-Exec
----------
provider "aws" {
    region = "us-west-2"
  }
  
  resource "aws_instance" "example" {
    ami           = "ami-0c55b159cbfafe1f0"
    instance_type = "t2.micro"
  
    # Other instance configuration (e.g., security groups, key pair, etc.)
  
    provisioner "local-exec" {
      command = "echo 'Instance created!'"
    }
  }

Remote-Exec
-----------
resource "aws_instance" "example" {
    ami           = "ami-0c55b159cbfafe1f0"
    instance_type = "t2.micro"
    connection {
        type        = "ssh"
        user        = "your_username"
        password    = "your_password"
        host        = self.public_ip
      }
    # Other instance configuration (e.g., security groups, key pair, etc.)
  
    provisioner "remote-exec" {
      inline = [
        "sudo apt-get update",
        "sudo apt-get install -y apache2",
      ]
    }
  }
 ==================================================================
 terraform import
 ============
 resource "aws_instance" "example" {
    # ...instance configuration...
}
$ terraform import aws_instance.example i-abcd1234
==================================================================
multiple resources creation in mutliple regions in terraform
-------------------------------------------------------
provider "aws" {
    alias  = "eu-west-1"
    region = "eu-west-1"
  }
  
provider "aws" {
    alias  = "eu-south-1"
    region = "eu-south-1"
  }
resource "aws_instance" "example_west" {
    provider    = aws.eu-west-1
    ami         = "ami-654321"
    instance_type = "t2.micro"
    # Other instance configuration...
  }
  
resource "aws_instance" "example_south" {
    provider    = aws.eu-south-1
    ami         = "ami-987654"
    instance_type = "t2.micro"
    # Other instance configuration...
  }
==============================================================
terraform vaults
------------------------
provider "vault" {
    address = "https://vault.example.com"
  }
  
  data "vault_generic_secret" "myapp_secrets" {
    path = "myapp/secrets"
  }
  
  output "my_secret_value" {
    value = data.vault_generic_secret.myapp_secrets.data["my_secret_key"]
  }
=============================================================

terraform version
terraform fmt
terraform init
terraform validate
terraform plan
terraform apply
terraform destroy
terraform state list
terraform state show <resource_name>
terraform import <resource_type>.<resource_name> <existing_id> --> create resource blueprint with empty braces and execute terraform import aws_db_instance.testdb testdb --> stores the pulled data in state file cannot be seen in resource block we created. so execute terraform show to show the pulled data.
terraform state rm <resource_type>.<resource_name> --> removes the imported or normal resources
terraform output
terraform output -state=<path_to_state_file>
terraform graph
terraform workspace new <workspace_name>
terraform workspace list
terraform workspace select <workspace_name>
terraform providers
terraform refresh
terraform taint <resource_name> -->During the next terraform apply, the tainted resource will be destroyed and recreated, even if the Terraform configuration hasn't changed.
terraform untaint <resource_name>

===========================================
Life cycle(installation, version upgrade etc.) of Hashicorp vault cluster
    1. Download Vault: Download the Vault binary from the official HashiCorp website.
        curl -O https://releases.hashicorp.com/vault/<version>/vault_<version>_linux_amd64.zip
    2. Install Vault: Unzip the binary and move it to a directory in your PATH.
        unzip vault_<version>_linux_amd64.zip
        sudo mv vault /usr/local/bin/
    3. Verify Installation: Check the Vault version to verify the installation.
        vault --version
    4. Configure Vault: Create a configuration file (config.hcl) for Vault.
      storage "file" {
        path = "/opt/vault/data"
      }

      listener "tcp" {
        address     = "127.0.0.1:8200"
        tls_disable = 1
      }

      ui = true

      replication {
          primary {
            performance_standby = true
          }
        }
    5. Start Vault: Start Vault in development mode for initial setup.
        vault server -dev
    6. Initialize Vault: Initialize Vault to set up the storage backend and generate unseal keys.
        vault operator init
    7. Unseal Vault: Unseal Vault using the unseal keys generated during initialization.
      vault operator unseal <unseal-key-1>
      vault operator unseal <unseal-key-2>
      vault operator unseal <unseal-key-3>

Scaling OF Vault
==================
  1. Install Vault on New Node: Follow the installation steps to install Vault on the new node.
  2. Configure New Node: Use the same configuration file as the existing nodes.
  3. Join Cluster: Start the new Vault node and join it to the existing cluster.
    vault server -config=/path/to/config.hcl

Vault Secret Management
=====================
1. Enable KV Secrets Engine
    vault secrets enable -path=secret kv
2. Store a Secret
    vault kv put secret/mysecret key1="value1" key2="value2"
3. Read a Secret
    vault kv get secret/mysecret
4. Update a Secret
   vault kv put secret/mysecret key1="newvalue1" key2="newvalue2"
5. Delete a Secret
    vault kv delete secret/mysecret

Vault Key Management System (KMS)
================================
1. Enable Transit Secrets Engine
    vault secrets enable transit
2. Create a Key
    vault write -f transit/keys/my-key
3. Encrypt Data
    vault write transit/encrypt/my-key plaintext=$(base64 <<< "my secret data")
4. Decrypt Data
    vault write transit/decrypt/my-key ciphertext=<ciphertext>
5. Rotate Key
    vault write -f transit/keys/my-key/rotate

Certificate Management
========================
1. Enable PKI Secrets Engine
    vault secrets enable pki
    vault secrets tune -max-lease-ttl=8760h pki
2. Generate Root Certificate
    vault write pki/root/generate/internal common_name="example.com" ttl=8760h
3. Configure URLs
    vault write pki/config/urls \
    issuing_certificates="http://127.0.0.1:8200/v1/pki/ca" \
    crl_distribution_points="http://127.0.0.1:8200/v1/pki/crl"
4. Create a Role
    vault write pki/roles/example-dot-com \
    allowed_domains="example.com" \
    allow_subdomains=true \
    max_ttl="72h"
5. Issue a Certificate
    vault write pki/issue/example-dot-com common_name="test.example.com"

Vault Policies
================
Vault policies, on the other hand, are used to define access control rules for users and applications interacting with Vault.
        # Allow Terraform to read and write secrets in the "terraform/" path
        path "terraform/*" {
          capabilities = ["create", "read", "update", "delete", "list"]
        }

        # Allow Terraform to manage its own tokens
        path "auth/token/create" {
          capabilities = ["update"]
        }

        path "auth/token/lookup-self" {
          capabilities = ["read"]
        }

        path "auth/token/renew-self" {
          capabilities = ["update"]
        }

        path "auth/token/revoke-self" {
          capabilities = ["update"]
        }

        # Allow Terraform to read policies (if needed)
        path "sys/policies/acl" {
          capabilities = ["list"]
        }

        path "sys/policies/acl/*" {
          capabilities = ["read"]
        }

Policy for AWS Secrets Engine
============================
    # Allow Terraform to read and write secrets in the "terraform/" path
    path "terraform/*" {
      capabilities = ["create", "read", "update", "delete", "list"]
    }

    # Allow Terraform to manage its own tokens
    path "auth/token/create" {
      capabilities = ["update"]
    }

    path "auth/token/lookup-self" {
      capabilities = ["read"]
    }

    path "auth/token/renew-self" {
      capabilities = ["update"]
    }

    path "auth/token/revoke-self" {
      capabilities = ["update"]
    }

    # Allow Terraform to generate AWS credentials
    path "aws/creds/*" {
      capabilities = ["read"]
    }

To apply the policies through Cli
===================================
  vault policy write terraform-policy terraform-policy.hcl

Create the Policy Using Terraform
      provider "vault" {
        address = "https://vault.example.com"
      }

      resource "vault_policy" "db_read_policy" {
        name   = "db-read-policy"
        policy = file("db-policy.hcl")
      }

Create a Vault Token with the Policy
    resource "vault_token" "db_read_token" {
      policies = ["db-read-policy"]
    }

Use the Token in Your Application
      data "vault_generic_secret" "db_password" {
        path = "secret/data/db_password"
        token = vault_token.db_read_token.id
      }

      output "db_password" {
        value = data.vault_generic_secret.db_password.data["data"]["password"]
      }