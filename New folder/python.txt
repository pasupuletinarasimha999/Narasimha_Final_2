Core Python Skills
    Basic Syntax and Data Structures: Lists, dictionaries, sets, tuples, etc.
        Lists: Ordered, mutable collections.
            fruits = ['apple', 'banana', 'cherry']
            print(fruits[0])
            fruits[1] = 'blueberry' //Modifying elements
            fruits.append('date')
            fruits.remove('apple')
            squares = [x**2 for x in range(10)]

        Dictionaries: Unordered collections of key-value pairs, mutable.
            person = {'name': 'Alice', 'age': 25, 'city': 'New York'}
            print(person['name']) 
            person['age'] = 26
            person['email'] = 'alice@example.com' // adds key as email and value as value in the quotes
            del person['city'] //deletes both key and its value
            squares = {x: x**2 for x in range(10)}

        Sets: Unordered collections of unique elements, mutable.
             fruits = {'apple', 'banana', 'cherry'}
             fruits.add('date')
             fruits.remove('banana')
             print(a | b)
             print(a & b) 
             squares = {x**2 for x in range(10)}

        Tuples: Ordered, immutable collections.
            person = ('Alice', 25, 'New York')
            print(person[0])
            # Tuple unpacking
                name, age, city = person
                print(name)  # Output: Alice
                print(age)   # Output: 25
                print(city)  # Output: New York

    Control Flow: If statements, loops, and comprehensions.
        If Statements: Used to execute code based on conditions.
            # If-elif-else statement
                x = 5
                if x > 5:
                print("x is greater than 5")
                elif x == 5:
                print("x is equal to 5")
                else:
                print("x is less than 5")

        For Loops: Used to iterate over sequences.
                # For loop with a dictionary
                person = {'name': 'Alice', 'age': 25, 'city': 'New York'}
                for key, value in person.items():
                print(f"{key}: {value}")

                # Nested for loop
                for i in range(3):
                 for j in range(2):
                    print(f"i: {i}, j: {j}")

        While Loops: Used to execute code as long as a condition is true.
                # While loop
                    x = 0
                    while x < 5:
                    print(x)
                    x += 1  
        Comprehensions: Provide a concise way to create lists, dictionaries, and sets.
                squares = [x**2 for x in range(10)]
                print(squares)

    Functions:
        # Defining a function
        def greet(name):
            return f"Hello, {name}!"

        def greet(name="World"):
            return f"Hello, {name}!"
        print(greet())  # Output: Hello, World!
        print(greet("Alice"))  # Output: Hello, Alice!

        def print_args(*args):
            for arg in args:
                print(arg)
        print_args(1, 2, 3)  # Output: 1, 2, 3

        def print_kwargs(**kwargs):
        for key, value in kwargs.items():
            print(f"{key}: {value}")
        print_kwargs(name="Alice", age=25)  # Output: name: Alice, age: 25
=============================================================================================

    Modules: 
    Boto3 (AWS SDK for Python): Boto3 provides two main interfaces for interacting with AWS services: the client and the resource interfaces.
        Client Interface: The client interface provides low-level access to AWS services. It maps directly to the AWS service APIs.
        Resource Interface: The resource interface provides a higher-level, object-oriented API. It abstracts some of the complexities of the client interface

            import boto3
            from botocore.exceptions import NoCredentialsError, PartialCredentialsError
            # Initialize clients for various AWS services
            s3_client = boto3.client('s3')
            ec2_client = boto3.client('ec2')
            sqs_client = boto3.client('sqs')
            sns_client = boto3.client('sns')
            dynamodb_client = boto3.client('dynamodb')
            iam_client = boto3.client('iam')
            lambda_client = boto3.client('lambda')
            cloudwatch_client = boto3.client('cloudwatch')
            rds_client = boto3.client('rds')
            cloudformation_client = boto3.client('cloudformation')

            # S3 Operations
            def s3_operations():
            try:
                # List buckets
                buckets = s3_client.list_buckets()
                print("Buckets:", [bucket['Name'] for bucket in buckets['Buckets']])

                # Create a bucket
                s3_client.create_bucket(Bucket='my-new-bucket')

                # Upload a file
                s3_client.upload_file('local_file.txt', 'my-new-bucket', 'remote_file.txt')

                # Download a file
                s3_client.download_file('my-new-bucket', 'remote_file.txt', 'local_file.txt')

                # List objects in a bucket
                objects = s3_client.list_objects_v2(Bucket='my-new-bucket')
                print("Objects:", [obj['Key'] for obj in objects.get('Contents', [])])

                # Get an object
                obj = s3_client.get_object(Bucket='my-new-bucket', Key='remote_file.txt')
                print("Object content:", obj['Body'].read().decode('utf-8'))

                # Put an object
                s3_client.put_object(Bucket='my-new-bucket', Key='new_file.txt', Body='Hello, World!')

                # Delete an object
                s3_client.delete_object(Bucket='my-new-bucket', Key='remote_file.txt')

                # Delete a bucket
                s3_client.delete_bucket(Bucket='my-new-bucket')

                # Get paginator
                paginator = s3_client.get_paginator('list_objects_v2')
                for page in paginator.paginate(Bucket='my-new-bucket'):
                    print("Page:", page)

            except (NoCredentialsError, PartialCredentialsError) as e:
                print("Credentials not available:", e)

            # EC2 Operations
            def ec2_operations():
            try:
                # Run instances
                ec2_client.run_instances(ImageId='ami-0abcdef1234567890', MinCount=1, MaxCount=1, InstanceType='t2.micro')

                # Describe instances
                instances = ec2_client.describe_instances()
                for reservation in instances['Reservations']:
                    for instance in reservation['Instances']:
                        print("Instance ID:", instance['InstanceId'])

                # Start instances
                ec2_client.start_instances(InstanceIds=['i-1234567890abcdef0'])

                # Stop instances
                ec2_client.stop_instances(InstanceIds=['i-1234567890abcdef0'])

                # Terminate instances
                ec2_client.terminate_instances(InstanceIds=['i-1234567890abcdef0'])

                # Create image
                ec2_client.create_image(InstanceId='i-1234567890abcdef0', Name='my-image')

                # Describe images
                images = ec2_client.describe_images(Owners=['self'])
                print("Images:", [image['ImageId'] for image in images['Images']])

                # Create security group
                ec2_client.create_security_group(GroupName='my-security-group', Description='My security group')

                # Authorize security group ingress
                ec2_client.authorize_security_group_ingress(GroupName='my-security-group', IpPermissions=[
                    {'IpProtocol': 'tcp', 'FromPort': 22, 'ToPort': 22, 'IpRanges': [{'CidrIp': '0.0.0.0/0'}]}
                ])

                # Describe security groups
                security_groups = ec2_client.describe_security_groups()
                print("Security Groups:", [sg['GroupName'] for sg in security_groups['SecurityGroups']])

            except (NoCredentialsError, PartialCredentialsError) as e:
                print("Credentials not available:", e)

            # SQS Operations
            def sqs_operations():
            try:
                # Create queue
                sqs_client.create_queue(QueueName='my-queue')

                # Get queue URL
                queue_url = sqs_client.get_queue_url(QueueName='my-queue')['QueueUrl']

                # Send message
                sqs_client.send_message(QueueUrl=queue_url, MessageBody='Hello, World!')

                # Receive message
                messages = sqs_client.receive_message(QueueUrl=queue_url)
                for message in messages.get('Messages', []):
                    print("Message:", message['Body'])

                    # Delete message
                    sqs_client.delete_message(QueueUrl=queue_url, ReceiptHandle=message['ReceiptHandle'])

                # Delete queue
                sqs_client.delete_queue(QueueUrl=queue_url)

            except (NoCredentialsError, PartialCredentialsError) as e:
                print("Credentials not available:", e)

            # SNS Operations
            def sns_operations():
            try:
                # Create topic
                topic_arn = sns_client.create_topic(Name='my-topic')['TopicArn']

                # Subscribe
                sns_client.subscribe(TopicArn=topic_arn, Protocol='email', Endpoint='example@example.com')

                # Publish
                sns_client.publish(TopicArn=topic_arn, Message='Hello, World!')

                # Unsubscribe
                subscriptions = sns_client.list_subscriptions_by_topic(TopicArn=topic_arn)
                for subscription in subscriptions['Subscriptions']:
                    sns_client.unsubscribe(SubscriptionArn=subscription['SubscriptionArn'])

                # Delete topic
                sns_client.delete_topic(TopicArn=topic_arn)

            except (NoCredentialsError, PartialCredentialsError) as e:
                print("Credentials not available:", e)

            # DynamoDB Operations
            def dynamodb_operations():
            try:
                # Create table
                dynamodb_client.create_table(
                    TableName='my-table',
                    KeySchema=[{'AttributeName': 'id', 'KeyType': 'HASH'}],
                    AttributeDefinitions=[{'AttributeName': 'id', 'AttributeType': 'S'}],
                    ProvisionedThroughput={'ReadCapacityUnits': 5, 'WriteCapacityUnits': 5}
                )

                # Put item
                dynamodb_client.put_item(TableName='my-table', Item={'id': {'S': '123'}, 'name': {'S': 'Alice'}})

                # Get item
                item = dynamodb_client.get_item(TableName='my-table', Key={'id': {'S': '123'}})
                print("Item:", item['Item'])

                # Update item
                dynamodb_client.update_item(
                    TableName='my-table',
                    Key={'id': {'S': '123'}},
                    UpdateExpression='SET name = :val1',
                    ExpressionAttributeValues={':val1': {'S': 'Bob'}}
                )

                # Delete item
                dynamodb_client.delete_item(TableName='my-table', Key={'id': {'S': '123'}})

                # Query
                response = dynamodb_client.query(
                    TableName='my-table',
                    KeyConditionExpression='id = :val1',
                    ExpressionAttributeValues={':val1': {'S': '123'}}
                )
                print("Query result:", response['Items'])

                # Scan
                response = dynamodb_client.scan(TableName='my-table')
                print("Scan result:", response['Items'])

                # Delete table
                dynamodb_client.delete_table(TableName='my-table')

            except (NoCredentialsError, PartialCredentialsError) as e:
                print("Credentials not available:", e)

            # IAM Operations
            def iam_operations():
            try:
                # Create user
                iam_client.create_user(UserName='my-user')

                # Attach user policy
                iam_client.attach_user_policy(UserName='my-user', PolicyArn='arn:aws:iam::aws:policy/AmazonS3FullAccess')

                # List users
                users = iam_client.list_users()
                print("Users:", [user['UserName'] for user in users['Users']])

                # Detach user policy
                iam_client.detach_user_policy(UserName='my-user', PolicyArn='arn:aws:iam::aws:policy/AmazonS3FullAccess')

                # Delete user
                iam_client.delete_user(UserName='my-user')

                # Create role
                iam_client.create_role(
                    RoleName='my-role',
                    AssumeRolePolicyDocument=json.dumps({
                        'Version': '2012-10-17',
                        'Statement': [
                            {
                                'Effect': 'Allow',
                                'Principal': {'Service': 'ec2.amazonaws.com'},
                                'Action': 'sts:AssumeRole'
                            }
                        ]
                    })
                )

                # List roles
                roles = iam_client.list_roles()
                print("Roles:", [role['RoleName'] for role in roles['Roles']])

                # Delete role
                iam_client.delete_role(RoleName='my-role')

            except (NoCredentialsError, PartialCredentialsError) as e:
                print("Credentials not available:", e)

            # Lambda Operations
            def lambda_operations():
            try:
                # Create function
                with open('lambda_function.zip', 'rb') as f:
                    zipped_code = f.read()

                lambda_client.create_function(
                    FunctionName='my-function',
                    Runtime='python3.8',
                    Role='arn:aws:iam::123456789012:role/service-role/my-role',
                    Handler='lambda_function.lambda_handler',
                    Code={'ZipFile': zipped_code}
                )

                # Invoke function
                response = lambda_client.invoke(FunctionName='my-function', InvocationType='RequestResponse')
                print("Response:", response['Payload'].read().decode('utf-8'))

                # List functions
                functions = lambda_client.list_functions()
                print("Functions:", [function['FunctionName'] for function in functions['Functions']])

                # Update function code
                with open('lambda_function.zip', 'rb') as f:
                    zipped_code = f.read()

                lambda_client.update_function_code(FunctionName='my-function', ZipFile=zipped_code)

                # Get function
                function = lambda_client.get_function(FunctionName='my-function')
                print("Function:", function)

                # Delete function
                lambda_client.delete_function(FunctionName='my-function')

            except (NoCredentialsError, PartialCredentialsError) as e:
                print("Credentials not available:", e)

            # CloudWatch Operations
            def cloudwatch_operations():
            try:
                # Put metric data
                cloudwatch_client.put_metric_data(
                    Namespace='MyNamespace',
                    MetricData=[
                        {
                            'MetricName': 'MyMetric',
                            'Dimensions': [{'Name': 'InstanceId', 'Value': 'i-1234567890abcdef0'}],
                            'Value': 1.0
                        }
                    ]
                )

                # Get metric data
                response = cloudwatch_client.get_metric_data(
                    MetricDataQueries=[
                        {
                            'Id': 'm1',
                            'MetricStat': {
                                'Metric': {
                                    'Namespace': 'MyNamespace',
                                    'MetricName': 'MyMetric',
                                    'Dimensions': [{'Name': 'InstanceId', 'Value': 'i-1234567890abcdef0'}]
                                },
                                'Period': 60,
                                'Stat': 'Average'
                            }
                        }
                    ],
                    StartTime=datetime.utcnow() - timedelta(minutes=10),
                    EndTime=datetime.utcnow()
                )
                print("Metric data:", response['MetricDataResults'])

                # Create alarm
                cloudwatch_client.put_metric_alarm(
                    AlarmName='MyAlarm',
                    MetricName='MyMetric',
                    Namespace='MyNamespace',
                    Statistic='Average',
                    Period=60,
                    EvaluationPeriods=1,
                    Threshold=1.0,
                    ComparisonOperator='GreaterThanThreshold',
                    ActionsEnabled=False
                )

                # Describe alarms
                alarms = cloudwatch_client.describe_alarms()
                print("Alarms:", [alarm['AlarmName'] for alarm in alarms['MetricAlarms']])

                # Delete alarms
                cloudwatch_client.delete_alarms(AlarmNames=['MyAlarm'])

            except (NoCredentialsError, PartialCredentialsError) as e:
                print("Credentials not available:", e)

            # RDS Operations
            def rds_operations():
            try:
                # Create DB instance
                rds_client.create_db_instance(
                    DBInstanceIdentifier='mydbinstance',
                    MasterUsername='admin',
                    MasterUserPassword='password',
                    DBInstanceClass='db.t2.micro',
                    Engine='mysql',
                    AllocatedStorage=20
                )

                # Describe DB instances
                db_instances = rds_client.describe_db_instances()
                print("DB Instances:", [db['DBInstanceIdentifier'] for db in db_instances['DBInstances']])

                # Start DB instance
                rds_client.start_db_instance(DBInstanceIdentifier='mydbinstance')

                # Stop DB instance
                rds_client.stop_db_instance(DBInstanceIdentifier='mydbinstance')

                # Delete DB instance
                rds_client.delete_db_instance(DBInstanceIdentifier='mydbinstance', SkipFinalSnapshot=True)

            except (NoCredentialsError, PartialCredentialsError) as e:
                print("Credentials not available:", e)

            # CloudFormation Operations
            def cloudformation_operations():
            try:
                # Create stack
                cloudformation_client.create_stack(
                    StackName='mystack',
                    TemplateBody=json.dumps({
                        'Resources': {
                            'MyBucket': {
                                'Type': 'AWS::S3::Bucket',
                                'Properties': {'BucketName': 'my-bucket'}
                            }
                        }
                    })
                )

                # Describe stacks
                stacks = cloudformation_client.describe_stacks()
                print("Stacks:", [stack['StackName'] for stack in stacks['Stacks']])

                # Update stack
                cloudformation_client.update_stack(
                    StackName='mystack',
                    TemplateBody=json.dumps({
                        'Resources': {
                            'MyBucket': {
                                'Type': 'AWS::S3::Bucket',
                                'Properties': {'BucketName': 'my-updated-bucket'}
                            }
                        }
                    })
                )

                # Delete stack
                cloudformation_client.delete_stack(StackName='mystack')

            except (NoCredentialsError, PartialCredentialsError) as e:
                print("Credentials not available:", e)

            if __name__ == '__main__':
            s3_operations()
            ec2_operations()
            sqs_operations()
            sns_operations()
            dynamodb_operations()
            iam_operations()
            lambda_operations()
            cloudwatch_operations()
            rds_operations()
            cloudformation_operations()
========================================================================================
    File Handling and Error Handling: Reading from and writing to files.
            # Open a file for reading
            file = open('example.txt', 'r')

            # Open a file for writing
            file = open('example.txt', 'w')

            # Open a file for appending
            file = open('example.txt', 'a')

            # Open a file in binary mode for reading
            file = open('example.txt', 'rb')

            # Read the entire file
            with open('example.txt', 'r') as file:
            content = file.read()
            print(content)

            # Read one line at a time
            with open('example.txt', 'r') as file:
            line = file.readline()
            while line:
                print(line, end='')
                line = file.readline()

            # Read all lines into a list
            with open('example.txt', 'r') as file:
            lines = file.readlines()
            for line in lines:
                print(line, end='')

            # Write a single string to a file
            with open('example.txt', 'w') as file:
            file.write('Hello, World!\n')

            # Write multiple lines to a file
            lines = ['First line\n', 'Second line\n', 'Third line\n']
            with open('example.txt', 'w') as file:
            file.writelines(lines)

            file = open('example.txt', 'r')
            # Perform file operations
            file.close()

            Complete program for above
            ===============================
            def read_file(file_path):
                try:
                    with open(file_path, 'r') as file:
                        return file.read()
                except FileNotFoundError as e:
                    print(f"Error: The file {file_path} does not exist. {e}")
                except IOError as e:
                    print(f"Error: An I/O error occurred while reading {file_path}. {e}")
                else:
                    print("File read successfully.")
                finally:
                    print("Finished attempting to read the file.")

            def write_file(file_path, content):
                try:
                    with open(file_path, 'w') as file:
                        file.write(content)
                except IOError as e:
                    print(f"Error: An I/O error occurred while writing to {file_path}. {e}")
                else:
                    print("File written successfully.")
                finally:
                    print("Finished attempting to write to the file.")

                # Example usage
            file_path = 'example.txt'
            content_to_write = 'Hello, World!\nThis is a test file.'

            write_file(file_path, content_to_write)
            content_read = read_file(file_path)
            if content_read:
            print("File content:")
            print(content_read)
=========================================================================================
Advanced Python Skills
========================
    Object-Oriented Programming (OOP): Classes, inheritance, and polymorphism.
        A class is a blueprint for creating objects. An object is an instance of a class.
            # Define a class
                class Dog:
                # Class attribute
                species = "Canis familiaris"

                # Initializer / Instance attributes
                def __init__(self, name, age):
                    self.name = name
                    self.age = age

                # Instance method
                def description(self):
                    return f"{self.name} is {self.age} years old"

                # Another instance method
                def speak(self, sound):
                    return f"{self.name} says {sound}"

                # Create an instance of the class
                my_dog = Dog("Buddy", 3)

                # Access class attributes and methods
                print(my_dog.description())  # Output: Buddy is 3 years old
                print(my_dog.speak("Woof Woof"))  # Output: Buddy says Woof Woof
        
        Inheritance: Inheritance allows a class to inherit attributes and methods from another class.
            # Parent class
            class Animal:
            def __init__(self, name):
                self.name = name

            def speak(self):
                raise NotImplementedError("Subclass must implement abstract method")

            # Child class (inherits from Animal)
            class Dog(Animal):
            def speak(self):
                return f"{self.name} says Woof Woof"

            class Cat(Animal):
            def speak(self):
                return f"{self.name} says Meow"

            # Create instances of the child classes
            dog = Dog("Buddy")
            cat = Cat("Whiskers")

            print(dog.speak())  # Output: Buddy says Woof Woof
            print(cat.speak())  # Output: Whiskers says Meow
        
        Polymorphism: Polymorphism allows methods to be used interchangeably between different classes.
            class Bird(Animal):
                def speak(self):
                    return f"{self.name} says Chirp"

            # Function that takes an animal and calls its speak method
            def animal_sound(animal):
                print(animal.speak())

            # Create instances
            dog = Dog("Buddy")
            cat = Cat("Whiskers")
            bird = Bird("Tweety")

            # Call the function with different types of animals
            animal_sound(dog)  # Output: Buddy says Woof Woof
            animal_sound(cat)  # Output: Whiskers says Meow
            animal_sound(bird)  # Output: Tweety says Chirp

    Decorators and Generators: Advanced function usage.
        Decorators: Decorators are a way to modify or enhance functions or methods without changing their actual code.
            # Basic decorator
            def my_decorator(func):
                def wrapper():
                    print("Something is happening before the function is called.")
                    func()
                    print("Something is happening after the function is called.")
                return wrapper
            @my_decorator
            def say_hello():
                print("Hello!")
            say_hello()
            # Output:
            # Something is happening before the function is called.
            # Hello!
            # Something is happening after the function is called.
        
        Decorators with Arguments:
        ---------------------------
            def repeat(num_times):
            def decorator_repeat(func):
                def wrapper(*args, **kwargs):
                    for _ in range(num_times):
                        func(*args, **kwargs)
                return wrapper
            return decorator_repeat

            @repeat(num_times=3)
            def greet(name):
            print(f"Hello {name}")
            greet("Alice") # 3 times we will get Hello Alice

            Class-based Decorators
            ---------------------
            class CountCalls:
                def __init__(self, func):
                    self.func = func
                    self.num_calls = 0
                def __call__(self, *args, **kwargs):
                    self.num_calls += 1
                    print(f"Call {self.num_calls} of {self.func.__name__}")
                    return self.func(*args, **kwargs)

            @CountCalls
            def say_hello():
                print("Hello!")
            say_hello()
            say_hello()

            Output:
                Call 1 of say_hello
                Hello!
                Call 2 of say_hello
                Hello

            Stacking Decorators
            ----------------------
            def decorator1(func):
                def wrapper():
                    print("Decorator 1")
                    func()
                return wrapper
            def decorator2(func):
                def wrapper():
                    print("Decorator 2")
                    func()
                return wrapper
            @decorator1
            @decorator2
            def say_hello():
            print("Hello!")
            say_hello()

            Output:
                Decorator 1
                Decorator 2
                Hello!
            
            Using functools.wraps
            -----------------
            import functools
            def my_decorator(func):
                @functools.wraps(func)
                def wrapper(*args, **kwargs):
                    print("Something is happening before the function is called.")
                    result = func(*args, **kwargs)
                    print("Something is happening after the function is called.")
                    return result
                return wrapper

            @my_decorator
            def say_hello():
            print("Hello!")
            print(say_hello.__name__)  # Output: say_hello

        Generators: Generators are a way to create iterators using a function with the yield keyword.
            def my_generator():
                yield 1
                yield 2
                yield 3
            gen = my_generator()
            print(next(gen))  # Output: 1
            print(next(gen))  # Output: 2
            print(next(gen))  # Output: 3 

            Using send Method
            ----------------
            def generator():
                value = yield
                print(f"Received: {value}")
            gen = generator()
            next(gen)  # Start the generator
            gen.send("Hello") # Received: Hello

            Using close Method
            ------------------
            def generator():
                try:
                    yield 1
                    yield 2
                except GeneratorExit:
                    print("Generator closed")

            gen = generator()
            print(next(gen))
            gen.close()

            Output:
                1
                Generator closed

            Using throw Method
            -----------------
            def generator():
                try:
                    yield 1
                except ValueError:
                    print("ValueError caught")

            gen = generator()
            print(next(gen))
            gen.throw(ValueError)

            Output:
            1
            ValueError caught
            
    Concurrency: Threading, multiprocessing, and async programming.
        Threading: Threading allows you to run multiple threads (smaller units of a process) concurrently.
            import threading
                def print_numbers():
                    for i in range(5):
                        print(i)
                # Create a thread
                thread = threading.Thread(target=print_numbers)
                # Start the thread
                thread.start()
                # Wait for the thread to finish
                thread.join()
    Multiprocessing: Multiprocessing allows you to run multiple processes concurrently, each with its own Python interpreter.
            import multiprocessing
            def print_numbers():
                for i in range(5):
                     print(i)
            # Create a process
            process = multiprocessing.Process(target=print_numbers)
            # Start the process
            process.start()
            # Wait for the process to finish
            process.join()

    Pandas: For data manipulation and analysis.
    NumPy: For numerical computing.
    PyYAML: For parsing and writing YAML, useful for configuration files.
    Django: A high-level web framework.
    FastAPI: A modern, fast (high-performance) web framework for building APIs.
    unittest: The built-in Python module for testing.
    mock: For mocking objects in tests.
    Psycopg2: For PostgreSQL database interaction.
    PyMySQL: For MySQL database interaction.
------------------------------------------------------------------------------------------
    Pytest: For testing -> A test function in Pytest is simply a function whose name starts with test_. You can use Python's built-in assert statement to check for expected outcomes.
        # test_example.py
        def test_addition():
            assert 1 + 1 == 2
        def test_subtraction():
            assert 2 - 1 == 1
    To run tests, navigate to the directory containing your test files and run the pytest command. Pytest will automatically discover and run all test functions in files that start with test_.
    Grouping Tests: You can group tests into classes. Note that the class name should start with Test, and the methods should start with test_.
    # test_example.py
        class TestMathOperations:
            def test_addition(self):
                assert 1 + 1 == 2
            def test_subtraction(self):
                assert 2 - 1 == 1
    Markers: Markers are used to add metadata to tests. You can define custom markers and use them to selectively run tests.
    # test_example.py
        import pytest
        @pytest.mark.slow
        def test_slow_function():
            import time
            time.sleep(5)
            assert True
        # Run tests with the "slow" marker
        pytest -m slow
-------------------------------------------------------------------------------------------
    Flask: A lightweight web framework.
Essential Libraries and Tools
    Boto3: The AWS SDK for Python, which allows you to interact with AWS services.
    AWS CLI: Command Line Interface for AWS, which can be invoked from Python scripts using subprocess.
    Paramiko: For SSH connections, useful for managing EC2 instances.
    Fabric: For streamlining the use of SSH for application deployment or systems administration tasks.
    Requests: For making HTTP requests, useful for interacting with REST APIs.
    PyTest: For writing and running tests.
    Invoke: A task execution library that helps in automating repetitive tasks
    Click: A package for creating command-line interfaces.

