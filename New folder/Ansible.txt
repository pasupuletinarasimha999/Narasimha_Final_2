What does `--ask-sudo-pass` do in Ansible? (or) How do you specify a sudo password when running an Ansible playbook?
Specify sudo password: ansible-playbook playbook.yml -i inventory.ini --user=username --ask-sudo-pass

1. How do you pass variables to an Ansible playbook from the command line? (or) What is the purpose of `--extra-vars` in Ansible?
	pass variable to ansible playbook in the command line: ansible-playbook release.yml --extra-vars "version=1.23.45 other_variable=foo"

2. How do you disable SSH host key checking in Ansible? (or) Where do you configure SSH host key checking settings in Ansible? 
The ansible.cfg file is not automatically generated by Ansible. Instead, it is a configuration file that you can create and customize to control the behavior of Ansible. You can create this file manually in your project directory, your home directory, or use the default configuration provided by Ansible.
		In /etc/ansible/ansible.cfg, add this line 
		[defaults]
		host_key_checking = False

				(or)
		Add in ssh known hosts
		- name: Write the new ec2 instance host key to known hosts
		  connection: local
		  shell: "ssh-keyscan -H {{ inventory_hostname }} >> ~/.ssh/known_hosts"

3. How do you run specific tasks in an Ansible playbook? (or) What are tags used for in Ansible?
		tasks:

					- yum: name={{ item }} state=installed
					  with_items:
						 - httpd
						 - memcached
					  tags:
						 - packages

					- template: src=templates/src.j2 dest=/etc/foo.conf
					  tags:
						 - configuration
					
	ansible-playbook example.yml --tags "configuration,packages"

4. What is the difference between an Ansible playbook and a role? (or) How do you define roles in an Ansible playbook?
		[databases] is a single name for a group of hosts. It allows you to reference multiple hosts by a single name.
		Role is a set of tasks and additional files to configure host to serve for a certain role.
		Playbook is a mapping between hosts and roles.

					Inside playbook (webservers.yml) you have something like:
							---
							- hosts: webservers <- this group of hosts defined in /etc/ansible/hosts, databases and mail_servers in example from your question
							  roles: <- this is list of roles to assign to these hosts
								- common
								- webservers

5. How do you write a multiline shell script in Ansible? (or) What does the `|` symbol do in an Ansible task?
 add | for multiline
		- shell:
			cmd: |
			  cat <<EOF
			  This is a test.
			  EOF

6. How do you move or rename a file in Ansible? (or) What modules are used to move or rename files in Ansible?
		- name: Copy files from foo to bar
		  copy: remote_src=True src=/path/to/foo dest=/path/to/bar
		  file: path=/path/to/foo state=absent
		  
7. How do you install roles in Ansible? (or) What is the purpose of `ansible-galaxy`?
ansible-galaxy install -r requirements.yml -> install role

8. How do you delete files and directories in Ansible? (or) What does the `state: absent` directive do in the `file` module?
	- name: Delete content & directory
	  ansible.builtin.file:
		state: absent
		path: /home/mydata/web/

9. What is `with_fileglob` used for in Ansible? (or) How do you iterate over files in a directory in Ansible?
with_fileglob -> with_fileglob is a lookup plugin in Ansible that allows you to iterate over files in a directory that match a specific pattern. This is particularly useful when you need to perform actions on multiple files that share a common naming convention or file extension.
	- copy:
		src: "{{ item }}"
		dest: /etc/fooapp/
		owner: root
		mode: 600
	  with_fileglob:
		- "/playbooks/files/fooapp/*"

10. How do you copy multiple files in Ansible? (or) What is the `loop` directive used for in Ansible?
copy-multiple-files-with-ansible
		- name: copy multiple items
			copy: 
			  src: "{{ item.src }}" 
			  dest: "{{ item.dest }}"
			loop:
			  - src: containerizers
				dest: /etc/mesos/containerizers
			  - src: another_file
				dest: /etc/somewhere
			  - src: dynamic
				dest: "{{ var_path }}"

11. How do you set environment variables in Ansible? (or) What is the `environment` directive used for in Ansible?
	  - hosts: dev
		  tasks:
			- name: Echo my_env_var
			  shell: "echo $MY_ENV_VARIABLE"
			  environment:
				MY_ENV_VARIABLE: whatever_value

			- name: Echo my_env_var again
			  shell: "echo $MY_ENV_VARIABLE"
12. What is the difference between `defaults` and `vars` in an Ansible role?
- Where do you define default variables in an Ansible role?
     
	 
13. What are the key directories in an Ansible role? (or) What is the purpose of the `templates` directory in an Ansible role?
Folder structure of ansible role : templates, files, vars, defaults, handlers, meta,tasks,tests
		1. templates
			Purpose: Contains Jinja2 template files.
			Usage: Templates are used to dynamically generate configuration files or other text files based on variables.
			Example:	jinja2
			[myapp]
			setting1 = {{ setting1 }}
			setting2 = {{ setting2 }}
		2. files
			Purpose: Contains static files that need to be transferred to remote hosts.
			Usage: Use the copy or fetch module to transfer these files.
			# tasks/main.yml
			- name: Copy static file
			  copy:
				src: myfile.txt
				dest: /etc/myapp/myfile.txt
		3. vars
			Purpose: Contains variable files that define variables used in the role.
			Usage: Variables defined here can be used throughout the role.
			# vars/main.yml
			---
			my_variable: "value"
		4. defaults
			Purpose: Contains default variables for the role.
			Usage: These variables can be overridden by other variable definitions (e.g., in playbooks or inventory).
			# defaults/main.yml
			---
			setting1: "default_value1"
			setting2: "default_value2"
		5. handlers
			Purpose: Contains handlers that are triggered by tasks.
			Usage: Handlers are typically used to restart services or perform other actions that should only occur if a change is made.  handler is a special type of task that is triggered by other tasks using the notify directive. Handlers are typically used to perform actions that should only occur if a change is made, such as restarting a service after a configuration file has been updated. Handlers are only run once, even if they are notified multiple times during a playbook run. Handlers are defined in a separate section, usually in the same playbook or role, under the handlers keyword. Handlers are defined in a handlers section
			# handlers/main.yml
			---
			- name: restart nginx
			  service:
				  name: nginx
				  state: restarted
			
			Using notify to Trigger a Handler. Tasks can notify handlers when they make changes. The notify directive specifies the name of the handler to be triggered.

				tasks:
				  - name: Copy nginx configuration file
					copy:
					  src: /path/to/nginx.conf
					  dest: /etc/nginx/nginx.conf
					notify: restart nginx
			
		6. meta
			Purpose: Contains metadata about the role, such as dependencies.
			Usage: Define role dependencies and other metadata.
			# meta/main.yml
			---
			dependencies:
			  - role: another_role
		7. tasks
			Purpose: Contains the main list of tasks to be executed by the role.
			Usage: Define the tasks that the role will perform.
			# tasks/main.yml
			---
			- name: Install myapp
			  apt:
				name: myapp
				state: present

			- name: Copy configuration file from template
			  template:
				src: config.j2
				dest: /etc/myapp/config.conf
			  notify: Restart myapp
		8. tests
			Purpose: Contains test playbooks and inventory files to test the role.
			Usage: Use these files to verify that the role works as expected.
			# tests/test.yml
			---
			- hosts: localhost
			  roles:
				- my_role

14. What is the order of variable precedence in Ansible? (or) How do extra-vars compare to role defaults in terms of precedence?
Variable precedence in ansible 
			Extra-vars (command-line variables)
			Role variables (vars/main.yml)
			Playbook variables
			Inventory variables
			Role defaults (defaults/main.yml)
			
15. What does `gather_facts` do in Ansible? (or) How do you disable fact gathering in an Ansible playbook? 
gather_facts: gather_facts is a directive in Ansible that controls whether or not to collect facts about the remote hosts before executing tasks. Facts are system properties and environment details collected by Ansible using the setup module. These facts include information such as IP addresses, operating system details, memory, disk space, and more. When you run a playbook, Ansible automatically gathers facts at the beginning of the playbook run (unless gather_facts: no is specified). These facts are stored in the ansible_facts dictionary and can be accessed using Jinja2 templating syntax.

16. What are some frequently used modules in Ansible? (or) How do you manage packages on Debian-based systems using Ansible? 
Frequently used modules in ansible
		1. ping
				Purpose: Checks the connectivity of the remote hosts.
				- name: Ping all hosts
				  hosts: all
				  tasks:
					- name: Ping the remote host
					  ping:
		2. command
				Purpose: Executes a command on the remote host.
				- name: Run a command on the remote host
				  hosts: all
				  tasks:
					- name: Run uptime command
					  command: uptime
		3. shell
				Purpose: Executes a shell command on the remote host.
				- name: Run a shell command on the remote host
				  hosts: all
				  tasks:
					- name: Run a shell command
					  shell: "echo $HOME"
		4. copy
				Purpose: Copies files from the local machine to the remote host.
				- name: Copy a file to the remote host
				  hosts: all
				  tasks:
					- name: Copy file
					  copy:
						src: /path/to/local/file
						dest: /path/to/remote/file
		5. template
				Purpose: Copies a Jinja2 template from the local machine to the remote host.
				- name: Copy a template to the remote host
				  hosts: all
				  tasks:
					- name: Copy template
					  template:
						src: /path/to/template.j2
						dest: /path/to/remote/file
		6. file
				Purpose: Manages files and directories on the remote host.
				- name: Create a directory on the remote host
				  hosts: all
				  tasks:
					- name: Create directory
					  file:
						path: /path/to/directory
						state: directory
		7. apt
				Purpose: Manages packages on Debian-based systems.
				- name: Install a package on Debian-based systems
				  hosts: all
				  tasks:
					- name: Install package
					  apt:
						name: nginx
						state: present
		8. yum
				Purpose: Manages packages on Red Hat-based systems.
				- name: Install a package on Red Hat-based systems
				  hosts: all
				  tasks:
					- name: Install package
					  yum:
						name: httpd
						state: present
		9. service
				Purpose: Manages services on the remote host.
				- name: Ensure a service is running
				  hosts: all
				  tasks:
					- name: Start service
					  service:
						name: nginx
						state: started
		10. user
				Purpose: Manages user accounts on the remote host.
				- name: Create a user on the remote host
				  hosts: all
				  tasks:
					- name: Create user
					  user:
						name: johndoe
						state: present
		11. group
				Purpose: Manages groups on the remote host.
				- name: Create a group on the remote host
				  hosts: all
				  tasks:
					- name: Create group
					  group:
						name: developers
						state: present
		12. git
				Purpose: Manages Git repositories on the remote host.
				- name: Clone a Git repository
				  hosts: all
				  tasks:
					- name: Clone repository
					  git:
						repo: 'https://github.com/example/repo.git'
						dest: /path/to/destination
		13. cron
				Purpose: Manages cron jobs on the remote host.
				- name: Create a cron job
				  hosts: all
				  tasks:
					- name: Add cron job
					  cron:
						name: "Backup job"
						minute: "0"
						hour: "2"
						job: "/usr/local/bin/backup.sh"
		14. lineinfile
				Copy Code
				- name: Ensure a line is present in a file
				  hosts: all
				  tasks:
					- name: Add line to file
					  lineinfile:
						path: /path/to/file
						line: "This is a new line"
		15. blockinfile
				Purpose: Ensures a block of multi-line text is present or absent in a file.
				- name: Ensure a block of text is present in a file
				  hosts: all
				  tasks:
					- name: Add block to file
					  blockinfile:
						path: /path/to/file
						block: |
						  This is a block of text
						  that spans multiple lines.
		16. set_fact
				Purpose: Sets host-level variables.
				- name: Set a fact
				  hosts: all
				  tasks:
					- name: Set custom fact
					  set_fact:
						my_custom_fact: "custom_value"
		17. debug
				Purpose: Prints statements during playbook execution for debugging purposes.
				- name: Print debug message
				  hosts: all
				  tasks:
					- name: Display a message
					  debug:
						msg: "This is a debug message"
		18. wait_for
				Purpose: Waits for a condition to be met before proceeding.
				- name: Wait for a port to be open
				  hosts: all
				  tasks:
					- name: Wait for port 80 to be open
					  wait_for:
						port: 80
						state: started
		19. synchronize
				Purpose: A wrapper around rsync to synchronize files between the local and remote hosts.
				- name: Synchronize files
				  hosts: all
				  tasks:
					- name: Sync files
					  synchronize:
						src: /path/to/local/dir/
						dest: /path/to/remote/dir/
		20. uri
				Purpose: Interacts with web services and APIs.
				- name: Make a GET request
				  hosts: all
				  tasks:
					- name: Fetch data from API
					  uri:
						url: "https://api.example.com/data"
						method: GET
						return_content: yes
					  register: result

					- name: Display API response
					  debug:
						msg: "{{ result.content }}"
		21. pip
		         Purpose: Install pip packages
				 - name: Install requirements
				  pip: 
					requirements: /my_app/requirements.txt
					virtualenv: /user/home/venvs/myenv
					virtualenv_python: python3.4

17. How do you enable verbose logging in Ansible? (or) What does the `-v` option do in `ansible-playbook`?
ANsible logs for playbooks using command : ansible-playbook -v playbook.yaml

18. Where is the default Ansible configuration file located? (or) How do you customize Ansible's behavior?
Ansible configuration file : /etc/ansible/ansible.cfg

19. What is `with_subelements` used for in Ansible? (or) How do you iterate over nested lists in Ansible?
subelements in ansible:
			---
			- hosts: localhost
			  gather_facts: no
			  vars:
				families:
				  - surname: Smith
					children:
					  - name: Mike
						age: 4
					  - name: Kate
						age: 7
				  - surname: Sanders
					children:
					  - name: Pete
						age: 12
					  - name: Sara
						age: 17

			  tasks:
				- name: List children
				  debug:
					msg: "Family={{ item.0.surname }} Child={{ item.1.name }} Age={{ item.1.age }}"
				  with_subelements:
					- "{{ families }}"
					- children
Task List children is like a nested loop over families list (outer loop) and over children subelement in each family (inner loop).So you should provide a list of dicts as first argument to subelements and name of subelement you want to iterate inside each outer item

20. How do you capture the output of a task in Ansible? (or) What is the `register` keyword used for in Ansible?
register in ansible : stores output
					- hosts: all
					  gather_facts: no
					  tasks:
						- shell: ps -eo pcpu,user,args | sort -r -k1 | head -n5
						  register: ps

						- debug: var=ps.stdout_lines

21. How do you ensure a line is present in a file in Ansible? (or) What is the `lineinfile` module used for in Ansible?
lineinfile: to add line to file, below example shows several lines addition 

		- name: Set some kernel parameters
		  lineinfile:
			dest: /etc/sysctl.conf
			regexp: "{{ item.regexp }}"
			line: "{{ item.line }}"
		  loop:
			- { regexp: '^kernel.shmall', line: 'kernel.shmall = 2097152' }
			- { regexp: '^kernel.shmmax', line: 'kernel.shmmax = 134217728' }
			- { regexp: '^fs.file-max', line: 'fs.file-max = 65536' }

22. What is `ansible_facts` in Ansible? (or) How do you access system properties in Ansible tasks?
Ansible_facts(used in tasks,templates, conditionals): ansible_facts is a special variable in Ansible that contains a collection of system properties and environment details about the remote hosts. These facts are gathered by the setup module, which is run automatically at the beginning of each play by default. The gathered facts provide detailed information about the remote hosts, such as their operating system, network interfaces, hardware details, and more.

23: Tasks: Tasks are the basic units of work in Ansible. They define actions to be performed on the remote hosts, such as installing packages, copying files, or restarting services. Tasks are defined within playbooks or roles and are executed sequentially.
		---
		- name: Example playbook with tasks
		  hosts: all
		  tasks:
			- name: Install Nginx
			  apt:
				name: nginx
				state: present

			- name: Copy configuration file
			  copy:
				src: /path/to/local/config.conf
				dest: /etc/nginx/nginx.conf

			- name: Restart Nginx
			  service:
				name: nginx
				state: restarted
		
		Templates: Templates are used to generate configuration files or other text files dynamically. They use the Jinja2 templating language to include variables and control structures. Templates are stored in the templates directory of a role or playbook and are processed by the template module.
		# templates/nginx.conf.j2
			server {
				listen 80;
				server_name {{ ansible_hostname }};
				root /var/www/html;
				index index.html;
				}
		
			Playbook Using the Template:
			---
			- name: Example playbook with templates
			  hosts: all
			  tasks:
				- name: Copy Nginx configuration from template
				  template:
					src: nginx.conf.j2
					dest: /etc/nginx/nginx.conf
		
		Conditionals: Conditionals are used to control the execution of tasks based on certain conditions. They allow you to make decisions and execute tasks only when specific criteria are met. Conditionals are defined using the when keyword in tasks.
		---
			- name: Example playbook with conditionals
			  hosts: all
			  tasks:
				- name: Install Nginx on Ubuntu
				  apt:
					name: nginx
					state: present
				  when: ansible_distribution == "Ubuntu"

				- name: Install httpd on CentOS
				  yum:
					name: httpd
					state: present
				  when: ansible_distribution == "CentOS"

				- name: Restart web server
				  service:
					name: "{{ ansible_distribution == 'Ubuntu' | ternary('nginx', 'httpd') }}"
					state: restarted

24. What does the `-k` option do in `ansible-playbook`? (or) How do you prompt for privilege escalation password in Ansible?
ansible-playbook mail.yml -kK 
		-k, --ask-pass: ask for connection password
		-K, --ask-become-pass: ask for privilege escalation password

25. How do you define or override variables dynamically in Ansible? (or) What is the `set_fact` module used for in Ansible?
Set_fact: The set_fact module in Ansible is used to define or override variables dynamically during the execution of a playbook. This allows you to create new variables or modify existing ones based on the results of previous tasks or other conditions. 
				- hosts: node1
				  gather_facts: yes
				  tasks:
				   - name: Check File
					 shell: ls -ld /etc/postfix/post-install
					 register: result
					 ignore_errors: yes

				   - name: Define Variable
					 set_fact:
						 exists: "{{ result.stdout }}"
					 when: result|success

				   - name: Display Variable
					 debug: msg="{{ exists }}"
					 ignore_errors: yes

26. How do you download files from the web in Ansible? (or) What is the `get_url` module used for in Ansible?
get_url-module: download file from web instead of wget
		- name: download sources
		  get_url: url={{ opencv.url }} dest={{ common.project_dir }}/{{ opencv.file }}

27. How do you loop over items in Ansible? (or) What is the `with_items` directive used for in Ansible?
with_items: loop over items
		- command: "{{ item }} chdir=/src/package/"
		  with_items:
		  - ./configure
		  - /usr/bin/make
		  - /usr/bin/make install    

28. What is the difference between `include_role` and `import_role` in Ansible? (or) When would you use `include_role` over `import_role`?
include_role vs import_role
		The include_role directive dynamically includes tasks from another role at runtime. This means that the tasks are included when the playbook is executed.
			---
			- name: Example playbook using include_role
			  hosts: all
			  tasks:
				- name: Include tasks from another role
				  include_role:
					name: other_role
		The import_role directive statically includes tasks from another role at parse time. This means that the tasks are included when the playbook is parsed, before execution begins. This can be more efficient in some cases.
			---
			- name: Example playbook using import_role
			  hosts: all
			  tasks:
				- name: Import tasks from another role
				  import_role:
					name: other_role

29. How do you capture and display command output in Ansible? (or) What is the `stdout_lines` attribute used for in Ansible?
stdout_lines: When you use the register keyword to capture the output of a task, the registered variable will contain several attributes, including stdout 
		- name: Show SSH public key
		  command: /bin/cat $home_directory/.ssh/id_rsa.pub
		  register: cat
		- debug: var=cat.stdout_lines

30. How do you access local environment variables in Ansible? (or) What is the `lookup` function used for in Ansible?
Ansible to access local environment variables: 
		- set_fact: env_var="{{ lookup('env','ENV_VAR') }}"

31. How do you iterate over the contents of a file in Ansible? (or) What is the `with_file` lookup plugin used for in Ansible?
with_file: the with_file lookup plugin is used to iterate over the contents of a file, line by line. This can be useful when you need to process each line of a file individually within a task.
				- name: Set up authorized keys for the deployer user
				  authorized_key: user=deployer key="{{item}}"
				  with_file:
					- /home/railsdev/.ssh/id_rsa.pub

32. How do you check if a service exists in Ansible? (or) What is the `stat` module used for in Ansible?
check-if-service-exists-with-ansible
		 - name: Check if Service Exists
			stat: path=/etc/init.d/{{service_name}}
			register: service_status

		  - name: Stop Service
			service: name={{service_name}} state=stopped
			when: service_status.stat.exists
			register: service_stopped

33. How do you retain temporary shell scripts in Ansible? (or) What does the `ANSIBLE_KEEP_REMOTE_FILES` environment variable do?
Save temporary ansible shell scripts instead of deleting: By default, Ansible executes shell commands and scripts on remote hosts by creating temporary files, running them, and then deleting these temporary files after execution. However, there might be scenarios where you want to retain these temporary files for debugging or auditing purposes.
		export ANSIBLE_KEEP_REMOTE_FILES=1

34: What is the difference between `become` and `become_user` in Ansible? (or) Difference between become and become_user in Ansible: 
		1. This task will be executed as root, because root is the default user for privilege escalation:
			- do: something
			  become: true
			  
		2. This task will be executed as user someone, because the user is explicitly set:
			- do: something
			  become: true
			  become_user: someone

35. How do you manage Python packages in Ansible? (or) What is the `ansible.builtin.pip` module used for in Ansible?
ansible.builtin.pip: module in Ansible is used to manage Python packages using the pip package manager. This module allows you to install, upgrade, and remove Python packages on remote hosts.
		---
		- name: Install Python packages using pip
		  hosts: all
		  tasks:
			- name: Install the requests package
			  ansible.builtin.pip:
				name: requests
				state: present

		ansible.builtin.copy: Copies files to remote locations.
		ansible.builtin.file: Manages files and file properties.
		ansible.builtin.fetch: Fetches files from remote machines to the local machine.
		ansible.builtin.template: Renders a Jinja2 template and copies it to a remote location.

		ansible.builtin.apt: Manages packages on Debian-based systems.
		ansible.builtin.yum: Manages packages on Red Hat-based systems.
		ansible.builtin.pip: Manages Python packages using pip.
		ansible.builtin.gem: Manages Ruby gems.

		ansible.builtin.service: Manages services.
		ansible.builtin.systemd: Manages systemd services.

		ansible.builtin.command: Executes commands on remote hosts.
		ansible.builtin.shell: Executes shell commands on remote hosts.
		ansible.builtin.raw: Executes raw commands on remote hosts.

		ansible.builtin.user: Manages user accounts.
		ansible.builtin.group: Manages groups.

		ansible.builtin.uri: Interacts with web services and APIs.
		ansible.builtin.get_url: Downloads files from the web.

		ansible.builtin.setup: Gathers facts about remote hosts.
		ansible.builtin.stat: Retrieves file or directory status.
		ansible.builtin.include_tasks: Includes tasks from another file.
		ansible.builtin.import_tasks: Imports tasks from another file.
		ansible.builtin.include_role: Includes a role.
		ansible.builtin.import_role: Imports a role.

		ansible.builtin.debug: Prints statements during playbook execution.
		ansible.builtin.wait_for: Waits for a condition to be met.
		ansible.builtin.set_fact: Sets host-level variables.

36. How do you encrypt files in Ansible? (or) What is the purpose of `ansible-vault`? (or) How do roles differ from playbooks in Ansible?
Ansible vault : ansible-vault --vault-password-file=vaultpass.txt encrypt sensitive_data.txt

37: What are the key components of Ansible? (or) How do roles differ from playbooks in Ansible?
		Inventory: A list of hosts or nodes.
		Playbooks: YAML files containing a series of tasks to be executed on the hosts.
		Modules: Reusable scripts that perform specific tasks.
		Plugins: Extend Ansible's core functionality.
		Roles: A way to organize playbooks and other files into reusable components.

38: How do you handle dependencies between roles in Ansible? (or) What is the purpose of the `meta/main.yml` file in an Ansible role?
  Dependencies between roles can be managed using the meta/main.yml file within a role. You can specify the dependencies in the dependencies section, and Ansible will ensure that the dependent roles are executed in the correct order. When you include a role in your playbook, Ansible will automatically check the meta/main.yml file for any dependencies and ensure they are installed. This helps to manage complex role dependencies and ensures that all required roles are available.

39. What is idempotency in Ansible? (or) Why is idempotency important in configuration management?
 Idempotency in Ansible means that running the same playbook multiple times will produce the same result. Ansible modules are designed to be idempotent, ensuring that they only make changes when necessary and avoid making changes if the desired state is already achieved.

40. How do you dynamically add hosts to the inventory in Ansible? (or) What is the `add_host` module used for in Ansible?
Add_host: add_host module in Ansible is used to dynamically add new hosts to the inventory during the execution of a playbook. This can be useful in scenarios where you need to create or discover new hosts on the fly and then perform tasks on those hosts within the same playbook run.

				---
				- name: Example Playbook to Add Hosts Dynamically
				  hosts: localhost
				  gather_facts: no
				  tasks:
					- name: Add a new host to the inventory
					  add_host:
						name: new_host
						groups: dynamic_group
						ansible_ssh_user: ubuntu
						ansible_ssh_private_key_file: /path/to/private/key

					- name: Add another host with additional variables
					  add_host:
						name: another_host
						groups: dynamic_group
						ansible_ssh_user: ubuntu
						ansible_ssh_pass: password

				- name: Perform tasks on the dynamically added hosts
				  hosts: dynamic_group
				  gather_facts: no
				  tasks:
					- name: Ping the new hosts
					  ping:
		Explanation
			First Play:
			The first play runs on localhost and uses the add_host module to add two new hosts (new_host and another_host) to a group called dynamic_group.
			The ansible_ssh_user and other connection variables are specified for each host.
			
			Second Play:
			The second play runs on the dynamic_group, which now includes the hosts added in the first play.
			The ping module is used to verify connectivity to the newly added hosts.\

41. How do you delegate tasks to a different host
delegate_to: The delegate_to keyword in Ansible is used to delegate a task to a different host than the one currently being targeted by the play. This is useful in scenarios where you need to perform certain tasks on a specific host, such as a control node, while the rest of the playbook runs on other hosts.
			---
			- name: Example Playbook Using delegate_to
			  hosts: webservers
			  gather_facts: no
			  tasks:
				- name: Ensure web server is running
				  service:
					name: apache2
					state: started

				- name: Fetch the latest code from the repository
				  git:
					repo: 'https://github.com/example/repo.git'
					dest: /var/www/html
				  delegate_to: control_node

				- name: Run a command on the control node
				  command: uptime
				  delegate_to: control_node

				- name: Copy a file from the control node to the web server
				  copy:
					src: /path/on/control_node/file.txt
					dest: /path/on/webserver/file.txt
				  delegate_to: control_node
				  run_once: true
	First Task:
		Runs on all hosts in the webservers group to ensure the Apache web server is running.
	Second Task:
		Uses the git module to fetch the latest code from a repository.
		This task is delegated to the control_node, meaning it will run on the control_node instead of the webservers.
	Third Task:
		Runs the uptime command on the control_node.
		This task is also delegated to the control_node.
	Fourth Task:
		Copies a file from the control_node to the web server.
		The run_once: true directive ensures that this task runs only once, even if there are multiple hosts in the webservers group.
		
42. What is the purpose of the `rescue` block in Ansible? (or) How do you handle errors in Ansible playbooks? (or) What is the difference between `block`, `rescue`, and `always` in Ansible?
Rescue: the rescue block is part of the error handling mechanism within a playbook. It allows you to define a set of tasks that should be executed if a preceding task fails. This is useful for implementing custom error recovery logic, ensuring that your playbook can handle failures gracefully. Ansible provides a structured way to handle errors using the block, rescue, and always directives:

	block: Groups a set of tasks together.
	rescue: Defines tasks to run if any task within the block fails.
	always: Defines tasks that should always run, regardless of whether the preceding tasks succeeded or failed.
			- name: Example playbook with error handling
			  hosts: all
			  tasks:
				- name: Main block
				  block:
					- name: Task that might fail
					  command: /bin/false

				  rescue:
					- name: Task to run if the main block fails
					  debug:
						msg: "The main block failed, running rescue tasks."

				  always:
					- name: Task to always run
					  debug:
						msg: "This task runs regardless of the success or failure of the main block."
